/*
 * LoraWAN_reply.c
 *
 * Created: 4/16/2025 2:55:41 PM
 * Author : Katherine Trusinski and Stanley Cokro
 * Description: Bi-directional communication with address-based replies.
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <stdio.h>

#define USART1_BAUD_RATE(BAUD_RATE) ((float)(4000000 * 64 / (16 * (float)BAUD_RATE)) + 0.5)
#define F_CPU 4000000

// Buffer sizes
#define RECEIVED_BUFFER_SIZE 80
#define PAYLOAD_BUFFER_SIZE 40
#define REPLY_BUFFER_SIZE 80

// Buffers and control variables
char received_message[RECEIVED_BUFFER_SIZE] = {0}; // Buffer for incoming message
volatile uint8_t received_index = 0;              // Index for incoming message
volatile uint8_t message_complete = 0;            // Flag for completed message

char payload[PAYLOAD_BUFFER_SIZE] = {0};          // Buffer for extracted payload
char reply_message[REPLY_BUFFER_SIZE] = {0};      // Buffer for outgoing reply

// Additional fields for parsing
char RCV_preamble[10] = {0};
volatile uint16_t txmtr_address = 0;   // Transmitter address
volatile uint16_t rcv_data_len = 0;   // Received data length
volatile int16_t RSSI = 0;            // RSSI value
volatile int16_t SNR = 0;             // SNR value

// Device address for LW1
#define LW1_ADDRESS 2 

// Function prototypes
void USART1_Init(uint32_t baud, uint8_t data_bits, unsigned char parity);
unsigned char USART1_Receive(void);
void USART1_Transmit(uint8_t data);
void parse_received_message(void);
void send_reply_message(void);

int main(void)
{
    USART1_Init(115200, 8, 'd'); // Initialize USART1
    sei(); // Enable global interrupts

    while (1)
    {
        // Check if a message is received
        if (message_complete)
        {
            message_complete = 0; // Reset the flag
            parse_received_message(); // Parse the message

            // Verify if the message is from PC (bench + 30)
            if (txmtr_address == (LW1_ADDRESS + 30))
            {
                send_reply_message(); // Send the reply message back to bench + 30
            }
        }
    }

    return 0;
}

// Function to initialize USART1
void USART1_Init(uint32_t baud, uint8_t data_bits, unsigned char parity)
{
    // Configure pins for TX and RX
    PORTC.DIR &= ~PIN1_bm; // RXD as input
    PORTC.DIR |= PIN0_bm;  // TXD as output
    PORTC.OUT |= PIN0_bm;  // TXD idle state high

    // Set the baud rate
    USART1.BAUD = USART1_BAUD_RATE(baud);

    // Enable TX, RX, and RX Complete interrupt
    USART1.CTRLB |= (USART_RXEN_bm | USART_TXEN_bm);

    // Configure parity
    uint8_t p;
    switch (parity)
    {
        case 'd':
            p = USART_PMODE_DISABLED_gc;
            break;
        case 'e':
            p = USART_PMODE_EVEN_gc;
            break;
        case 'o':
            p = USART_PMODE_ODD_gc;
            break;
        default:
            return;
    }

    // Configure data bits
    uint8_t d;
    switch (data_bits)
    {
        case 8:
            d = USART_CHSIZE_8BIT_gc;
            break;
        case 7:
            d = USART_CHSIZE_7BIT_gc;
            break;
        case 6:
            d = USART_CHSIZE_6BIT_gc;
            break;
        case 5:
            d = USART_CHSIZE_5BIT_gc;
            break;
        default:
            return;
    }

    // Configure USART control settings
    USART1.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | p | USART_SBMODE_1BIT_gc | d;
}

// Function to receive a single byte
unsigned char USART1_Receive(void)
{
    while (!(USART1.STATUS & USART_RXCIF_bm)); // Wait for incoming data
    return USART1.RXDATAL; // Return received data
}

// Function to transmit a single byte
void USART1_Transmit(uint8_t data)
{
    while (!(USART1.STATUS & USART_DREIF_bm)); // Wait for the transmit buffer to be ready
    USART1.TXDATAL = data; // Send data
}

// Function to parse the received message
void parse_received_message(void)
{
    sscanf(received_message, "+RCV=%[^=]=%u,%u,%[^,],%d,%d",
           RCV_preamble, &txmtr_address, &rcv_data_len, payload, &RSSI, &SNR);
}

// Function to send the reply message
void send_reply_message(void)
{
    snprintf(reply_message, REPLY_BUFFER_SIZE, "+SEND=%u,%s\r\n", LW1_ADDRESS + 30, payload);

    for (uint8_t i = 0; reply_message[i] != '\0'; i++)
    {
        USART1_Transmit(reply_message[i]); // Transmit each character
    }
}
